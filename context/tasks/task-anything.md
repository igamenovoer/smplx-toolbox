# Fixing errors in t2m skeleton to smplx mapping

I think we have some misunderstanding over the retargeting from humanml pose to smplx pose, we need to investigate this problem systemically, make a plan: 
- forget about global orientation and translation, set them to 0s, focus on the bone rotations (pose vector)
- only focus on bones (joints) shared by humanml and smplx
- do not take current documentation about t2m to smplx mapping as granted, there may be errors
- use keypoint fitting to verify the retargeting, if retargeting is correct, the result should be consistent with keypoint fitting
- first, check t2m source code (`context/refcode/HumanML3D`) again, find out how to generate a netural pose of t2m skeleton, save them into .pkl file, name this `t2m_neutral`, should contain `t2m_neutral.joints` (3d keypoints), `t2m_neutral.pose` (6d rotations of 22 joints), but orientation and translation are 0s
- create a neutral pose of smplx, with global orientation and translation set to 0s, get keypoint positions of this neutral pose, then fit the smplx model to `t2m_neutral.joints` by keypoint fitting, allowing pose/shape/translation/orientation to vary, verify the fitting result, the state is called `smplx_neutral_fit` (as a `UnifiedSmplInputs`). Note that `smplx_neutral_fit` will have global orientation and translation not 0s, because it differ from t2m neutral pose by translation or orientation.
- get a frame from humanml output `results_ext.npy`, get its 3d keypoints, pose (6d rotations of 22 joints), global orientation (6d), global translation, save them into a .pkl file, name this `t2m_frame`, should contain `t2m_frame.joints` (3d keypoints), `t2m_frame.pose` (6d rotations of 22 joints), `t2m_frame.root_orient` (global orientation in 6d), `t2m_frame.trans` (global translation). Inverse transform the keypoints to the origin (making root_orient and translation to 0s), so that we can focus on the bone rotations (pose vector) only. After inverse transform, save the new keypoints to `t2m_frame_no_transform.pkl`, should contain `t2m_frame_no_transform.joints` (3d keypoints), `t2m_frame_no_transform.pose` (6d rotations of 22 joints), `t2m_frame_no_transform.root_orient` (global orientation in 6d, all 0s), `t2m_frame_no_transform.trans` (global translation, all 0s).
- now we need to test a comparison: 
  - fit smplx to `t2m_frame_no_transform.joints` by keypoint fitting, based on `smplx_neutral_fit` as initialisation, allowing pose to vary only (fix shape/orient/translation), verify the fitting result, the state is called `smplx_frame_fit` (as a `UnifiedSmplInputs`)
  - retarget smplx pose from `t2m_frame_no_transform.pose` (6d rotations of 22 joints), based on `smplx_neutral_fit` as initialisation, and this state is called `smplx_frame_retarget` (as a `UnifiedSmplInputs`).
  - compare `smplx_frame_fit` and `smplx_frame_retarget` by final keypoint positions (forward them into smplx model, get keypoint positions), they should be very close. If not, there must be some error in the retargeting process.